
#import "RCTCmbSdk.h"

#import <cmbSDK/cmbSDK.h>
#import <CMBCrossPlatform/CMBCrossPlatform.h>
#import "RCTCmbEvent.h"

@interface RCTCmbSdk() <CMBReaderDeviceDelegate, CMBObserversDelegate>

@property CCPBridge *cmb;

@end

@implementation RCTCmbSdk

- (dispatch_queue_t)methodQueue
{
    return dispatch_get_main_queue();
}

RCT_EXPORT_MODULE()

#define CODE_NO_ERROR @"0"

+(BOOL)requiresMainQueueSetup {
    return YES;
}

- (instancetype)init
{
    self = [super init];
    
    if (self) {
        self.cmb = [[CCPBridge alloc] init];
        self.cmb.ccpPluginDelegate = self;
        self.cmb.ccpPluginScanningStateDelegate = self;
    }

    return self;
}

- (CCPCompletionWithResponse) createResponseWithResolver:(RCTPromiseResolveBlock)resolver rejecter:(RCTPromiseRejectBlock)rejecter {
    return ^(NSString* errorCode, NSString * _Nonnull response) {
        if ([errorCode intValue] != 0) {
            rejecter(errorCode, response, [self createErrorWithCode:errorCode message:response]);
        } else {
            resolver(response);
        }
    };
}

RCT_REMAP_METHOD(loadScanner, deviceType:(int)deviceType loadScannerResolver:(RCTPromiseResolveBlock)loadScannerResolver loadScannerRejecter:(RCTPromiseRejectBlock)loadScannerRejecter)
{
    [self.cmb initReaderWithClass:deviceType callback:^{
        if (loadScannerResolver) {
            loadScannerResolver(@(YES));
        }
    }];
}

RCT_REMAP_METHOD(connect, connectResolver:(RCTPromiseResolveBlock)connectResolver connectRejecter:(RCTPromiseRejectBlock)connectRejecter)
{
    [self.cmb connect:[self createResponseWithResolver:connectResolver rejecter:connectRejecter]];
}

RCT_REMAP_METHOD(disconnect, disconnectResolver:(RCTPromiseResolveBlock)disconnectResolver disconnectRejecter:(RCTPromiseRejectBlock)disconnectRejecter)
{
    [self.cmb disconnect:[self createResponseWithResolver:disconnectResolver rejecter:disconnectRejecter]];
}

RCT_REMAP_METHOD(startScanning, startScanningResolver:(RCTPromiseResolveBlock)startScanningResolver startScanningRejecter:(RCTPromiseRejectBlock)startScanningRejecter)
{
    [self.cmb startScanning:[self createResponseWithResolver:startScanningResolver rejecter:startScanningRejecter]];
}

RCT_REMAP_METHOD(stopScanning, stoptScanningResolver:(RCTPromiseResolveBlock)stopScanningResolver stopScanningRejecter:(RCTPromiseRejectBlock)stopScanningRejecter)
{
    [self.cmb stopScanning:[self createResponseWithResolver:stopScanningResolver rejecter:stopScanningRejecter]];
}

RCT_EXPORT_METHOD(setSymbology:(int)symbology enabled:(BOOL)arg commandIdentifier:(nonnull NSString*) cmdIdentifier)
{
    __weak typeof(self) weakSelf = self;
    [self.cmb setSymbology:symbology enabled:arg completion:^(NSString * _Nonnull errorCode, NSString * _Nonnull response) {
        RCTCmbEvent *symbologyEvent = [RCTCmbEvent.alloc initEvent:CMBEventCommandCompleted];
        symbologyEvent.eventBody = @{@"commandID":cmdIdentifier, @"success": @([errorCode isEqualToString:CODE_NO_ERROR]), @"message":response, @"eventType":@"setSymbology"};

        [symbologyEvent sendUsingEmitter:weakSelf];
    }];
}

RCT_EXPORT_METHOD(isSymbologyEnabled:(int)symbology commandIdentifier:(nonnull NSString*) cmdIdentifier)
{
    [self.cmb isSymbologyEnabled:symbology completion:^(NSString * _Nonnull errorCode, NSString * _Nonnull response) {
        RCTCmbEvent *symbologyEvent = [RCTCmbEvent.alloc initEvent:CMBEventCommandCompleted];
        symbologyEvent.eventBody = @{@"commandID":cmdIdentifier, @"success": @([errorCode isEqualToString:CODE_NO_ERROR]), @"message":response, @"eventType":@"isSymbologyEnabled"};

        [symbologyEvent sendUsingEmitter:self];
    }];
}

RCT_EXPORT_METHOD(setCameraMode:(int)arg)
{
    [self.cmb setCameraMode:arg];
}

RCT_EXPORT_METHOD(setPreviewOptions:(int)arg)
{
    [self.cmb setPreviewOptions:arg];
}

RCT_EXPORT_METHOD(setPreviewOverlayMode:(int)arg) {
    [self.cmb setPreviewOverlayMode:arg];
}

RCT_EXPORT_METHOD(setPreviewContainerPositionAndSize:(NSArray*)args) {
    [self.cmb setPreviewContainerPositionAndSizeX:[args[0] floatValue] Y:[args[1] floatValue] width:[args[2] floatValue] height:[args[3] floatValue]];
}

RCT_EXPORT_METHOD(setPreviewContainerBelowStatusBar:(BOOL)arg){
    [self.cmb setPreviewContainerBelowStatusBar:arg];
}

RCT_EXPORT_METHOD(setPreviewContainerFullScreen){
    [self.cmb setPreviewContainerFullScreen];
}

RCT_EXPORT_METHOD(setLightsOn:(BOOL)arg setLightsResolver:(RCTPromiseResolveBlock)setLightsResolver setLightsRejecter:(RCTPromiseRejectBlock)setLightsRejecter)
{
    [self.cmb setLightsOn:arg completion:[self createResponseWithResolver:setLightsResolver rejecter:setLightsRejecter]];
}

RCT_REMAP_METHOD(isLightsOn, isLightsResolver:(RCTPromiseResolveBlock)isLightsResolver isLightsRejecter:(RCTPromiseRejectBlock)isLightsRejecter)
{
    [self.cmb isLightsOnWithCompletion:[self createResponseWithResolver:isLightsResolver rejecter:isLightsRejecter]];
}

RCT_EXPORT_METHOD(enableImage:(BOOL)arg resolver:(RCTPromiseResolveBlock)resolver rejecter:(RCTPromiseRejectBlock)rejecter) {
    [self.cmb enableImage:arg completion:[self createResponseWithResolver:resolver rejecter:rejecter]];
}

RCT_EXPORT_METHOD(enableImageGraphics:(BOOL)arg  resolver:(RCTPromiseResolveBlock)resolver rejecter:(RCTPromiseRejectBlock)rejecter){
    [self.cmb enableImageGraphics:arg completion:[self createResponseWithResolver:resolver rejecter:rejecter]];
}

RCT_EXPORT_METHOD(sendCommand:(NSString*)command commandIdentifier:(nonnull NSString*) cmdIdentifier)
{
    [self.cmb sendCommand:command completion:^(NSString * _Nonnull errorCode, NSString * _Nonnull response) {
        RCTCmbEvent *cmdEvent = [RCTCmbEvent.alloc initEvent:CMBEventCommandCompleted];
        cmdEvent.eventBody = @{@"commandID":cmdIdentifier, @"success": @([errorCode isEqualToString:CODE_NO_ERROR]), @"status":@([errorCode intValue]), @"message": response, @"eventType":@"command", @"command":command};
        
        [cmdEvent sendUsingEmitter:self];
    }];
}

RCT_REMAP_METHOD(resetConfig, resetConfigResolver:(RCTPromiseResolveBlock)resetConfigResolver resetConfigRejecter:(RCTPromiseRejectBlock)resetConfigRejecter)
{
    [self.cmb resetConfigWithCompletion:[self createResponseWithResolver:resetConfigResolver rejecter:resetConfigRejecter]];
}

RCT_EXPORT_METHOD(registerSDK:(NSString*)arg){
    [self.cmb registerSDK:arg];
}

RCT_REMAP_METHOD(getAvailability, availabilityResolver:(RCTPromiseResolveBlock)availabilityResolver availabilityRejecter:(RCTPromiseRejectBlock)availabilityRejecter)
{
    [self.cmb getAvailability:[self createResponseWithResolver:availabilityResolver rejecter:availabilityRejecter]];
}

RCT_REMAP_METHOD(getConnectionState, getConnectionStateResolver:(RCTPromiseResolveBlock)getConnectionStateResolver getConnectionStateRejecter:(RCTPromiseRejectBlock)getConnectionStateRejecter){
    [self.cmb getConnectionState:[self createResponseWithResolver:getConnectionStateResolver rejecter:getConnectionStateRejecter]];
}

RCT_REMAP_METHOD(beep, beepResolver:(RCTPromiseResolveBlock)beepResolver beepRejecter:(RCTPromiseRejectBlock)beepRejecter)
{
    [self.cmb beep:[self createResponseWithResolver:beepResolver rejecter:beepRejecter]];
}

RCT_REMAP_METHOD(getDeviceBatteryLevel, batteryStateResolver:(RCTPromiseResolveBlock)batteryStateResolver batteryStateRejecter:(RCTPromiseRejectBlock)batteryStateRejecter)
{
    [self.cmb getDeviceBatteryLevel:[self createResponseWithResolver:batteryStateResolver rejecter:batteryStateRejecter]];
}

RCT_EXPORT_METHOD(getSdkVersion:(RCTPromiseResolveBlock)sdkVersionResolver sdkVersionRejecter:(RCTPromiseRejectBlock)sdkVersionRejecter) {
    [self.cmb getSdkVersion:[self createResponseWithResolver:sdkVersionResolver rejecter:sdkVersionRejecter]];
}

RCT_EXPORT_METHOD(setStopScannerOnRotate:(BOOL)arg){
    [self.cmb setStopScannerOnRotate:arg];
}

RCT_EXPORT_METHOD(enableCameraFlag:(NSDictionary *)arg flagResolver:(RCTPromiseResolveBlock)flagResolver flagRejecter:(RCTPromiseRejectBlock)flagRejecter) {
    [self.cmb enableCameraFlag:[arg[@"flag"] intValue] forMask:[arg[@"codeMask"] intValue] completion:[self createResponseWithResolver:flagResolver rejecter:flagRejecter]];
}

RCT_EXPORT_METHOD(disableCameraFlag:(NSDictionary *)arg flagResolver:(RCTPromiseResolveBlock)flagResolver flagRejecter:(RCTPromiseRejectBlock)flagRejecter) {
    [self.cmb disableCameraFlag:[arg[@"flag"] intValue] forMask:[arg[@"codeMask"] intValue] completion:[self createResponseWithResolver:flagResolver rejecter:flagRejecter]];
}

RCT_EXPORT_METHOD(setCameraParam:(NSDictionary *)arg resolver:(RCTPromiseResolveBlock)resolver rejecter:(RCTPromiseRejectBlock)rejecter) {
    int mask = [arg[@"codeMask"] intValue];
    int param = [arg[@"param"] intValue];
    int value = [arg[@"value"] intValue];
    
    int result = MWB_setParam(mask, param, value);
    if (result == MWB_RT_OK) {
        resolver(@"");
    } else {
        NSString *resultAsString = [@(result) stringValue];
        rejecter(resultAsString, resultAsString, [self createErrorWithCode:resultAsString message:resultAsString]);
    }
}

RCT_REMAP_METHOD(getCameraExposureCompensationRange, resolver:(RCTPromiseResolveBlock)resolver rejecter:(RCTPromiseRejectBlock)rejecter) {
    [self.cmb getCameraExposureCompensationRange:[self createResponseWithResolver:resolver rejecter:rejecter]];
}

RCT_EXPORT_METHOD(setCameraExposureCompensation:(float)arg resolver:(RCTPromiseResolveBlock)resolver rejecter:(RCTPromiseRejectBlock)rejecter) {
    [self.cmb setCameraExposureCompensation:arg completion:[self createResponseWithResolver:resolver rejecter:rejecter]];
}

RCT_EXPORT_METHOD(setParser:(int)arg  resolver:(RCTPromiseResolveBlock)resolver rejecter:(RCTPromiseRejectBlock)rejecter){
    [self.cmb setParser:arg completion:[self createResponseWithResolver:resolver rejecter:rejecter]];
}

RCT_EXPORT_METHOD(setReadStringEncoding:(int)arg setEncodingResolver:(RCTPromiseResolveBlock)setEncodingResolver setEncodingRejecter:(RCTPromiseRejectBlock)setEncodingRejecter){
    [self.cmb setReadStringEncoding:arg completion:[self createResponseWithResolver:setEncodingResolver rejecter:setEncodingRejecter]];
}

RCT_EXPORT_METHOD(setMDMReportingEnabled:(BOOL)arg) {
    [self.cmb setMDMReportingEnabled:arg];
}

RCT_EXPORT_METHOD(createMDMAuthCredentials:(NSString*)username password:(NSString*)password clientID:(NSString*) clientID clientSecret:(NSString*)clientSecret)
{
    [self.cmb createMDMAuthCredentialsWithUsername:username password:password clientID:clientID clientSecret:clientSecret];
}

#pragma mark - CMBReaderDevice Delegate

- (void)availabilityDidChangeOfReader:(CMBReaderDevice *)reader {
    RCTCmbEvent *availabilityEvent = [RCTCmbEvent.alloc initEvent:CMBEventAvailabilityChanged];
    availabilityEvent.eventBody = @(reader.availability);
    
    [availabilityEvent sendUsingEmitter:self];
}

- (void)connectionStateDidChangeOfReader:(CMBReaderDevice *)reader {
    RCTCmbEvent *connectionChangeEvent = [RCTCmbEvent.alloc initEvent:CMBEventConnectionStateChanged];
    connectionChangeEvent.eventBody = @(reader?reader.connectionState:0);
    
    [connectionChangeEvent sendUsingEmitter:self];
}

-(void)didReceiveReadResultFromReader:(CMBReaderDevice *)reader results:(CMBReadResults *)readResults
{
    NSString *jsonString = [CCPUtilities getResultsJSONStringFromResults:readResults keyResults:@"readResults" keySubResults:@"subReadResults"];
    NSDictionary *resultDict = [self convertStringToDictionary:jsonString];
    
    RCTCmbEvent *readResultEvent = [RCTCmbEvent.alloc initEvent:CMBEventReadResultReceived];
    readResultEvent.eventBody = resultDict;
    
    [readResultEvent sendUsingEmitter:self];
}

-(void)scanningStateChanged:(BOOL)isScanning {
    RCTCmbEvent *scanningStateEvent = [RCTCmbEvent.alloc initEvent:CMBEventScanningStateChanged];
    scanningStateEvent.eventBody = @(isScanning);
    
    [scanningStateEvent sendUsingEmitter:self];
}

#pragma mark - Utility

- (NSDictionary*)convertStringToDictionary:(NSString*)string {
    NSError* error;
    //giving error as it takes dic, array,etc only. not custom object.
    NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];
    id json = [NSJSONSerialization JSONObjectWithData:data options:0 error:&error];
    return json;
}

RCT_EXPORT_METHOD(imageFromSVG:(NSString*)svg imageFromSVGResolver:(RCTPromiseResolveBlock)imageFromSVGResolver imageFromSVGRejecter:(RCTPromiseRejectBlock)imageFromSVGRejecter)
{
    UIImage *svgImage = [CCPUtilities getImageFromSVGString:svg];
    if (svgImage) {
        imageFromSVGResolver([UIImagePNGRepresentation(svgImage) base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength]);
    } else {
        imageFromSVGRejecter(@"0", @"Failed to convert svg to image", nil);
    }
}

UIAlertController *cmbsdk_connectionAlert;
RCT_EXPORT_METHOD(toggleConnectionAlert:(BOOL)arg){
    if (arg) {
        if (!cmbsdk_connectionAlert) {
            cmbsdk_connectionAlert = [UIAlertController alertControllerWithTitle:@"Connecting" message:@"Please wait..." preferredStyle:UIAlertControllerStyleAlert];
            [UIApplication.sharedApplication.keyWindow.rootViewController presentViewController:cmbsdk_connectionAlert animated:YES completion:nil];
        }
    } else {
        if (cmbsdk_connectionAlert) {
            [cmbsdk_connectionAlert dismissViewControllerAnimated:YES completion:nil];
            cmbsdk_connectionAlert = nil;
        }
    }
}

- (NSArray<NSString *> *)supportedEvents {
    return [RCTCmbEvent.cmbEvents allValues];
}

RCT_EXPORT_METHOD(getSupportedEventNames:(RCTResponseSenderBlock)callback)
{
    callback([RCTCmbEvent.cmbEvents allValues]);
}

- (NSError *) createErrorWithCode:(NSString *)errorCode message:(NSString *)message {
    NSString *domain = [[NSBundle bundleForClass:self.class] bundleIdentifier];
    
    NSDictionary *userInfo = @{
        NSLocalizedDescriptionKey: NSLocalizedString(message, nil),
        NSLocalizedFailureReasonErrorKey: NSLocalizedString(message, nil),
        NSLocalizedRecoverySuggestionErrorKey: NSLocalizedString(message, nil)
    };

    return [NSError.alloc initWithDomain:domain code:[errorCode intValue] userInfo:userInfo];
}

@end
