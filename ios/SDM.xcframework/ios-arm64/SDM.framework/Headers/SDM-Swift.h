// Generated by Apple Swift version 5.3 (swiftlang-1200.0.29.2 clang-1200.0.30.1)
#ifndef SDM_SWIFT_H
#define SDM_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreBluetooth;
@import CoreGraphics;
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="SDM",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

enum DeviceTransportType : NSInteger;
@class Scan;
enum ConnectionState : NSInteger;
@class BatteryPowerState;
enum DeviceType : NSInteger;
enum TriggerReadType : NSInteger;

/// Base class for all devices
SWIFT_CLASS("_TtC3SDM6Device")
@interface Device : NSObject
/// Returns type of device transport
@property (nonatomic, readonly) enum DeviceTransportType transportType;
/// device options dictionary to save and restore device options
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull options;
/// optionsRestored shows if device options were found and restored
@property (nonatomic) BOOL optionsRestored;
/// last scanned tag/barcode
@property (nonatomic, strong) Scan * _Nullable currentTag;
/// Read/write operations timeout. Default value is 5 seconds
@property (nonatomic) NSTimeInterval readTimeout;
/// last happened error for this device
@property (nonatomic) NSError * _Nullable lastError;
/// device connection state
@property (nonatomic, readonly) enum ConnectionState state;
/// device name
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
/// device serial name
@property (nonatomic, readonly, copy) NSString * _Nonnull serialNumber;
/// device firmaware version, if available
@property (nonatomic, readonly, copy) NSString * _Nullable firmwareVersion;
/// device firmaware version, if available
@property (nonatomic, readonly, copy) NSString * _Nullable hardwareVersion;
/// device bluetooth address, if available
@property (nonatomic, readonly, copy) NSString * _Nullable bluetoothAddress;
/// true if device manufactured by Serialio Ltd.
@property (nonatomic, readonly) BOOL madeBySerialIO;
/// Show if device is genuine
@property (nonatomic, readonly) BOOL isGenuine;
/// When scan value is less symbols than fixed number, the output is “0” padded
@property (nonatomic) NSInteger fixedSymbolsCount;
/// Clips symbols at start of scan data
@property (nonatomic) NSInteger clipAtStart;
/// Clips symbols at end of scan data
@property (nonatomic) NSInteger clipAtEnd;
/// Clips leading zeros of scan data
@property (nonatomic) BOOL clipLeadingZeros;
/// Apply clipping to CSN/EPC
@property (nonatomic) BOOL clipCsn;
/// Apply clipping to TID
@property (nonatomic) BOOL clipTid;
/// Apply clipping to Userdata
@property (nonatomic) BOOL clipUserdata;
/// Apply clipping to NDEF text records
@property (nonatomic) BOOL clipNdefText;
/// Show if device support battery service
@property (nonatomic, readonly) BOOL supportBatteryService;
/// current battery power level, if device provides it and <code>batteryServiceEnabled</code> is true
@property (nonatomic, readonly) NSInteger batteryPercentage;
/// current power state, if device provides it and <code>batteryServiceEnabled</code> is true
@property (nonatomic, readonly, strong) BatteryPowerState * _Nonnull batteryPowerState;
/// device type
@property (nonatomic, readonly) enum DeviceType deviceType;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
@property (nonatomic, readonly) NSUInteger hash;
/// :nodoc:
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Returns device supported types of triggering read (inventory command)
@property (nonatomic, readonly) enum TriggerReadType supportedTriggerRead;
/// Trigger device to read data (inventory command), if device doesn’t support triggering of reading <code>dataType</code> happens nothing
/// seealso:
/// <code>Device.supportedTriggerRead</code>
/// \param dataType data type to read. allowed values: barcode or rfid
///
- (void)triggerReadingWithDataType:(enum TriggerReadType)dataType;
/// Shows if constantMode is supported by device
@property (nonatomic, readonly) BOOL supportsConstantReadMode;
/// Shows current value for constantMode if applicable
@property (nonatomic, readonly) BOOL constantModeEnabled;
@end

/// Enum defines device connection state
typedef SWIFT_ENUM(NSInteger, ConnectionState, open) {
///
  ConnectionStateDisconnected = 0,
///
  ConnectionStateConnecting = 1,
///
  ConnectionStateConnected = 2,
};

/// Enum defines possible triggering read
typedef SWIFT_ENUM(NSInteger, TriggerReadType, open) {
///
  TriggerReadTypeNothing = 0,
///
  TriggerReadTypeBarcode = 1,
///
  TriggerReadTypeRfid = 2,
///
  TriggerReadTypeBarcodeAndRfid = 3,
};


/// Allflex® RS420 : LPR : GPR+ : UWR+ device class, see base <code>Device</code> for all available methods
SWIFT_CLASS("_TtC3SDM13AllflexDevice")
@interface AllflexDevice : Device
@property (nonatomic, readonly) enum DeviceType deviceType;
@end

@class NSCoder;

/// view, to show battery status for supported devices
SWIFT_CLASS("_TtC3SDM16BatteryLevelView")
@interface BatteryLevelView : UIView
/// shows BatteryLevelView in parent view
+ (void)showIn:(UIView * _Nonnull)view;
/// hides BatteryLevelView
+ (void)hide;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
/// :nodoc:
- (void)layoutSubviews;
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end

enum ParameterValue : uint8_t;

///
SWIFT_CLASS("_TtC3SDM17BatteryPowerState")
@interface BatteryPowerState : NSObject
///
@property (nonatomic) enum ParameterValue batteryPresent;
///
@property (nonatomic) enum ParameterValue discharging;
///
@property (nonatomic) enum ParameterValue charging;
///
@property (nonatomic) enum ParameterValue criticalLowLevel;
/// :nodoc:
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) BatteryPowerState * _Nonnull unknown;)
+ (BatteryPowerState * _Nonnull)unknown SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

///
typedef SWIFT_ENUM(uint8_t, ParameterValue, open) {
///
  ParameterValueUnknown = 0,
///
  ParameterValueUnsupported = 1,
///
  ParameterValueNo = 2,
///
  ParameterValueYes = 3,
};


/// DeviceInfo used to store found device, after connectin to device, this device info isn’t valid
SWIFT_CLASS("_TtC3SDM10DeviceInfo")
@interface DeviceInfo : NSObject
/// Device type
@property (nonatomic, readonly) enum DeviceType deviceType;
/// Device name used in UI
@property (nonatomic, copy) NSString * _Nonnull displayName;
/// Device name from system
@property (nonatomic, readonly, copy) NSString * _Nonnull deviceName;
/// Serial number, can be empty
@property (nonatomic, copy) NSString * _Nonnull serialNumber;
/// Flag is device is <em>recent</em>, i.e. it was connected previosly and it has saved options
@property (nonatomic) BOOL optionsExists;
/// :nodoc:
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// DeviceInfo used to store found Bluetooth LE device
SWIFT_CLASS("_TtC3SDM13BleDeviceInfo")
@interface BleDeviceInfo : DeviceInfo
@end


/// BlueSnap® DB9 NFC device class, see base <code>Device</code> for all available methods
SWIFT_CLASS("_TtC3SDM17BlueSnapDB9Device")
@interface BlueSnapDB9Device : Device
/// flag for enable/disable posting scans only when trigger device to read data
/// seealso:
/// triggerReading(dataType: TriggerReadType)
@property (nonatomic) BOOL postScanTriggerOnly;
/// Posts data as HEX or ASCII
@property (nonatomic) BOOL postAsHex;
/// Set to false to disable parse readBuffer for scans
@property (nonatomic) BOOL needParseReadBuffer;
/// Plain data from scanner, set <code>needParseReadBuffer</code> to <code>false</code> to disable scans parsing
@property (nonatomic, copy) NSData * _Nonnull readBuffer;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull options;
@property (nonatomic, readonly) enum DeviceType deviceType;
@property (nonatomic, readonly) BOOL madeBySerialIO;
@property (nonatomic, readonly) enum TriggerReadType supportedTriggerRead;
- (void)triggerReadingWithDataType:(enum TriggerReadType)dataType;
@end












enum ScanDataFormat : NSInteger;

/// CipherLab 18xx device class, see base <code>Device</code> for all available methods
SWIFT_CLASS("_TtC3SDM19CipherLab1800Device")
@interface CipherLab1800Device : Device
/// set auto off timer on reader in seconds, default value is 8 mins
@property (nonatomic) NSInteger autoOff;
/// device antenna power output, 0…3 dBm for 1861 and 0…19 for 1862
@property (nonatomic) NSInteger outputPower;
/// enable or disable constant read mode, default value is false
@property (nonatomic) BOOL constantReadMode;
/// format to read tag EPC, if it doesn’t equals <code>.none</code> Scan <code>data</code> will be set
@property (nonatomic) enum ScanDataFormat epcOutputFormat;
/// format to read tag userdata, if it doesn’t equals <code>.none</code> Scan <code>userdata</code> or <code>ndef</code> will be set
@property (nonatomic) enum ScanDataFormat userdataOutputFormat;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull options;
@property (nonatomic, readonly) enum DeviceType deviceType;
@property (nonatomic, readonly) BOOL supportsConstantReadMode;
@end






/// available transport types
typedef SWIFT_ENUM(NSInteger, DeviceTransportType, open) {
/// :nodoc:
  DeviceTransportTypeUnknown = 0,
/// WiSnap-connected devices
  DeviceTransportTypeWisnap = 1,
/// Apple MFi® transport
  DeviceTransportTypeMfi = 2,
/// Bluetooth® LowEnergy transport
  DeviceTransportTypeBle = 3,
};

/// Supported device types
typedef SWIFT_ENUM(NSInteger, DeviceType, open) {
///
  DeviceTypeUnknown = 0,
///
  DeviceTypeWisnapM1 = 1,
///
  DeviceTypeWisnapM2 = 2,
///
  DeviceTypeChs7Ci = 3,
///
  DeviceTypeChs7Xi = 4,
///
  DeviceTypeScanfob3002 = 5,
///
  DeviceTypeScanfob4000 = 6,
///
  DeviceTypeTsl1128 = 7,
///
  DeviceTypeQid = 8,
///
  DeviceTypeEua = 9,
///
  DeviceTypeEub4 = 10,
///
  DeviceTypeScanfobBB2nfc = 11,
///
  DeviceTypeScanfobBB2ultra = 12,
///
  DeviceTypeIdChampRS3 = 13,
///
  DeviceTypeBlueSnapDB9 = 14,
///
  DeviceTypeScanfob2006 = 15,
///
  DeviceTypeSmart3101 = 16,
///
  DeviceTypeCipher1800 = 17,
///
  DeviceTypeDisto = 18,
///
  DeviceTypeIdChampRS4 = 19,
///
  DeviceTypeIdChampNF2 = 20,
///
  DeviceTypeIdChampNF4 = 21,
///
  DeviceTypeSrs2 = 22,
///
  DeviceTypeAllflex = 23,
///
  DeviceTypePosiTector = 24,
};

enum Unit : NSInteger;
enum RoundDown : NSInteger;

/// Leica DISTO™ device class, see base <code>Device</code> for all available methods
SWIFT_CLASS("_TtC3SDM11DistoDevice")
@interface DistoDevice : Device
/// convert measure to required units
@property (nonatomic) enum Unit unitFormat;
/// rounding read value
@property (nonatomic) enum RoundDown roundDownRange;
/// append measure units to value
@property (nonatomic) BOOL displayUnits;
@property (nonatomic, readonly) enum DeviceType deviceType;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull options;
@property (nonatomic, readonly) BOOL supportsConstantReadMode;
@property (nonatomic, readonly) enum TriggerReadType supportedTriggerRead;
- (void)triggerReadingWithDataType:(enum TriggerReadType)dataType;
@end

/// Distance units
typedef SWIFT_ENUM(NSInteger, Unit, open) {
///
  UnitFeet = 0,
///
  UnitInch = 1,
///
  UnitMetric = 2,
};

/// Rounding values type
typedef SWIFT_ENUM(NSInteger, RoundDown, open) {
///
  RoundDownNo = 0,
///
  RoundDownHalf = 1,
///
  RoundDownOneFourth = 2,
///
  RoundDownOneEighth = 3,
};


@class DriverLicenseDataItem;

/// PDF417 Data decoder for drivers license
SWIFT_CLASS("_TtC3SDM20DriverLicenseDecoder")
@interface DriverLicenseDecoder : NSObject
/// parse barcode for PDF417 driver license
- (nullable instancetype)initWithString:(NSString * _Nonnull)string OBJC_DESIGNATED_INITIALIZER;
- (NSString * _Nullable)objectForKeyedSubscript:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
/// all fields in the same order as coded from license. [DriverLicenseDataItem text] can be empty, eg. cell.textLabel.text = dld.fields[0].text ?: dld.fields[0].abbr; cell.detailsLabel.text = dld.fields[0].value
@property (nonatomic, readonly, copy) NSArray<DriverLicenseDataItem *> * _Nonnull fields;
/// returns info for known ABBR, firstName is stored under one of “DAC”, “DBP”, “DCT”, “DDF”
@property (nonatomic, readonly, copy) NSString * _Nullable firstName;
/// returns info for known ABBR, middleName is stored under one of “DAD”, “DBQ”, “DDG”
@property (nonatomic, readonly, copy) NSString * _Nullable middleName;
/// returns info for known ABBR, lastName is stored under one of “DAB”, “DBO”, “DCS”, “DDE”
@property (nonatomic, readonly, copy) NSString * _Nullable lastName;
/// returns info for known ABBR, fullName is stored under one of “DAA”, “DBN”
@property (nonatomic, readonly, copy) NSString * _Nullable fullName;
/// returns info for known ABBR, nameSuffix is stored under one of “DAF”, “DBS”
@property (nonatomic, readonly, copy) NSString * _Nullable nameSuffix;
/// returns info for known ABBR, namePrefix is stored under one of “DAE”, “DBR”, “DCU”
@property (nonatomic, readonly, copy) NSString * _Nullable namePrefix;
/// returns info for known ABBR, licenseNumber is stored under “DAQ”
@property (nonatomic, readonly, copy) NSString * _Nullable licenseNumber;
/// returns info for known ABBR, licenseExpirationDate is stored under “DBD”
@property (nonatomic, readonly, copy) NSString * _Nullable licenseExpirationDate;
/// returns info for known ABBR, licenseIssueDate is stored under “DBA”
@property (nonatomic, readonly, copy) NSString * _Nullable licenseIssueDate;
/// returns info for known ABBR, streetAddress1 is stored under one of “DAG”, “DAL”
@property (nonatomic, readonly, copy) NSString * _Nullable streetAddress1;
/// returns info for known ABBR, streetAddress2 is stored under one of “DAH”, “DAM”
@property (nonatomic, readonly, copy) NSString * _Nullable streetAddress2;
/// returns info for known ABBR, city is stored under one of “DAI”, “DAN”
@property (nonatomic, readonly, copy) NSString * _Nullable city;
/// returns info for known ABBR, state is stored under one of “DAJ”, “DAO”
@property (nonatomic, readonly, copy) NSString * _Nullable state;
/// returns info for known ABBR, zipcode is stored under one of “DAK”, “DAP”
@property (nonatomic, readonly, copy) NSString * _Nullable zipcode;
/// returns info for known ABBR, dateOfBirth is stored under one of “DBB”, “DBL”
@property (nonatomic, readonly, copy) NSString * _Nullable dateOfBirth;
/// returns info for known ABBR, sex is stored under “DBC”
@property (nonatomic, readonly, copy) NSString * _Nullable sex;
/// returns info for known ABBR, height is stored under one of “DAU”, “DAV”
@property (nonatomic, readonly, copy) NSString * _Nullable height;
/// returns info for known ABBR, weight is stored under one of “DAW”, “DAX”
@property (nonatomic, readonly, copy) NSString * _Nullable weight;
/// returns info for known ABBR, eyeColor is stored under “DAY”
@property (nonatomic, readonly, copy) NSString * _Nullable eyeColor;
/// returns info for known ABBR, hairColor is stored under “DAZ”
@property (nonatomic, readonly, copy) NSString * _Nullable hairColor;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end




/// Tag Frequency
typedef SWIFT_ENUM(NSInteger, Frequency, open) {
///
  FrequencyNone = 0,
/// Ultra High Frequency (UHF) 868 – 928 MHz, Samples: EPC Gen II tags and cards
  FrequencyUltraHigh = 1,
/// High Frequency (HF) 13,56 MHz, Samples: MIFARE and HID iClass cards
  FrequencyHigh = 2,
/// Low Frequency (LF) 120 – 125 kHz, Samples: Nedap and HID Prox cards
  FrequencyLow = 3,
};

enum TagType : NSInteger;
enum ScanDataType : NSInteger;

/// Obj-C Helper class
SWIFT_CLASS("_TtC3SDM6Helper")
@interface Helper : NSObject
/// Create string for value of TagType type
+ (NSString * _Nonnull)stringWithTagType:(enum TagType)tagType SWIFT_WARN_UNUSED_RESULT;
/// Create string for value of DeviceType type
+ (NSString * _Nonnull)stringWithDeviceType:(enum DeviceType)deviceType SWIFT_WARN_UNUSED_RESULT;
/// Create string for value of ScanDataType type
+ (NSString * _Nonnull)stringWithDataType:(enum ScanDataType)dataType SWIFT_WARN_UNUSED_RESULT;
/// Create string for value of ScanDataFormat type
+ (NSString * _Nonnull)stringWithDataFormat:(enum ScanDataFormat)dataFormat SWIFT_WARN_UNUSED_RESULT;
/// Create string for value of CBManagerState type
+ (NSString * _Nonnull)stringWithCbState:(CBManagerState)cbState SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// idChamp® EUA device class, see base <code>Device</code> for all available methods
SWIFT_CLASS("_TtC3SDM16IdChampEUADevice")
@interface IdChampEUADevice : Device
/// device antenna power output in percent, default value is 80%, qID:  iPow_Max_mW= 150 mW, EUA:  iPow_Max_mW= 500 mW, EUB4: iPow_Max_mW= 1000 mW
@property (nonatomic) NSInteger outputPower;
/// enable or disable constant read mode
@property (nonatomic) BOOL constantReadMode;
/// format to read tag EPC, if it doesn’t equals <code>.none</code> Scan <code>data</code> will be set
@property (nonatomic) enum ScanDataFormat epcOutputFormat;
/// format to read tag TID, if it doesn’t equals <code>.none</code> Scan <code>tid</code> will be set
@property (nonatomic) enum ScanDataFormat tidOutputFormat;
/// length of TID to read
@property (nonatomic) NSInteger tidLength;
/// format to read tag userdata, if it doesn’t equals <code>.none</code> Scan <code>userdata</code> or <code>ndef</code> will be set
@property (nonatomic) enum ScanDataFormat userdataOutputFormat;
/// max length of userdata to read
@property (nonatomic) NSInteger userdataLength;
/// set of enabled numbers of antenna (0…3), only EUB4
@property (nonatomic, copy) NSSet<NSNumber *> * _Nonnull antennas;
@property (nonatomic, readonly) BOOL madeBySerialIO;
@property (nonatomic, readonly) enum DeviceType deviceType;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull options;
@property (nonatomic, readonly) BOOL supportsConstantReadMode;
@property (nonatomic, readonly) enum TriggerReadType supportedTriggerRead;
- (void)triggerReadingWithDataType:(enum TriggerReadType)dataType;
@end



SWIFT_CLASS("_TtC3SDM15TagReaderDevice")
@interface TagReaderDevice : Device
@end

enum NFCDataFormat : NSInteger;

/// idChamp® NF2 device class, see base <code>Device</code> for all available methods
SWIFT_CLASS("_TtC3SDM16IdChampNF2Device")
@interface IdChampNF2Device : TagReaderDevice
/// format to read tag CSN, if it doesn’t equals <code>.none</code> Scan <code>data</code> will be set
@property (nonatomic) enum ScanDataFormat csnOutputFormat;
/// format to read tag userdata, if it doesn’t equals <code>.none</code> Scan <code>userdata</code> or <code>ndef</code> will be set
@property (nonatomic) enum ScanDataFormat userdataOutputFormat;
/// max length of userdata to read
@property (nonatomic) NSInteger userdataLength;
/// format of data stored on tag
@property (nonatomic) enum NFCDataFormat nfcDataFormat;
@property (nonatomic, readonly) enum DeviceType deviceType;
@property (nonatomic, readonly) BOOL madeBySerialIO;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull options;
@end

@class PacsProfile;

/// idChamp® NF4 device class, see base <code>Device</code> for all available methods
SWIFT_CLASS("_TtC3SDM16IdChampNF4Device")
@interface IdChampNF4Device : TagReaderDevice
/// show if tag is presented on reader
@property (nonatomic, readonly) BOOL isTagPresented;
/// enable beep on scan, Default is true
@property (nonatomic) BOOL beepOnScan;
/// enable or disable constant read mode
@property (nonatomic) BOOL constantReadMode;
/// format to read tag CSN, if it doesn’t equals <code>.none</code> Scan <code>data</code> will be set
@property (nonatomic) enum ScanDataFormat csnOutputFormat;
/// format to read tag userdata, if it doesn’t equals <code>.none</code> Scan <code>userdata</code> or <code>ndef</code> will be set
@property (nonatomic) enum ScanDataFormat userdataOutputFormat;
/// max length of userdata to read
@property (nonatomic) NSInteger userdataLength;
/// PACs profile to get value from PAC bits
@property (nonatomic, copy) NSArray<PacsProfile *> * _Nonnull pacsProfiles;
/// Number of bits to read. Value less 0 or more 128 are ignored
@property (nonatomic) NSInteger csnBitCount;
/// format of data stored on tag
@property (nonatomic) enum NFCDataFormat nfcDataFormat;
/// Append Facility Code to scan
@property (nonatomic) BOOL appendFacilityCode;
/// Delimiter to append Facility Code to scan
@property (nonatomic, copy) NSString * _Nonnull facilityCodeDelimiter;
/// Start bit for FacilityCode
@property (nonatomic) NSInteger facilityCodeStartBit;
/// Bits count for FacilityCode
@property (nonatomic) NSInteger facilityCodeBitsCount;
/// Applying csnBitCOunt option from left-to-right
@property (nonatomic) BOOL isNexWatchEnabled;
@property (nonatomic, readonly) enum DeviceType deviceType;
@property (nonatomic, readonly) BOOL madeBySerialIO;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull options;
@property (nonatomic, readonly) enum TriggerReadType supportedTriggerRead;
- (void)triggerReadingWithDataType:(enum TriggerReadType)dataType;
@property (nonatomic, readonly) BOOL supportsConstantReadMode;
@end





/// idChamp® RS3 device class, see base <code>Device</code> for all available methods
SWIFT_CLASS("_TtC3SDM16IdChampRS3Device")
@interface IdChampRS3Device : Device
/// format to read tag EPC, if it doesn’t equals <code>.none</code> Scan <code>data</code> will be set
@property (nonatomic) enum ScanDataFormat epcOutputFormat;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull options;
@property (nonatomic, readonly) enum DeviceType deviceType;
@property (nonatomic, readonly) BOOL madeBySerialIO;
@end

enum CredentialType : NSInteger;

/// idChamp® RS4 device class, see base <code>Device</code> for all available methods
SWIFT_CLASS("_TtC3SDM16IdChampRS4Device")
@interface IdChampRS4Device : TagReaderDevice
/// format to read tag credentials, if it doesn’t equals <code>ScanDataFormat.none</code> <code>Scan.data</code> will be set
@property (nonatomic) enum ScanDataFormat credentialOutputFormat;
/// type of credentials of tag to read
@property (nonatomic) enum CredentialType credentialType;
/// format to read tag userdata, if it doesn’t equals <code>ScanDataFormat.none</code> <code>Scan.userdata</code> or <code>Scan.ndef</code> will be set
@property (nonatomic) enum ScanDataFormat userdataOutputFormat;
/// max length of userdata to read
@property (nonatomic) NSInteger userdataLength;
/// format of data stored on tag
@property (nonatomic) enum NFCDataFormat nfcDataFormat;
/// show if tag is presented on reader
@property (nonatomic, readonly) BOOL isTagPresented;
@property (nonatomic, readonly) enum DeviceType deviceType;
@property (nonatomic, readonly) BOOL madeBySerialIO;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull options;
@end

/// Config cards parameters
typedef SWIFT_ENUM(NSInteger, ConfigParameter, open) {
///
  ConfigParameterIso14443a = 0,
///
  ConfigParameterIso14443b = 1,
///
  ConfigParameterIso15693 = 2,
///
  ConfigParameterIclass14443b = 3,
///
  ConfigParameterIclass15693 = 4,
///
  ConfigParameterFelica = 5,
///
  ConfigParameterProx = 6,
///
  ConfigParameterBle = 7,
///
  ConfigParameterConfigCard = 8,
};

/// Available credentials type for reading
typedef SWIFT_ENUM(NSInteger, CredentialType, open) {
///
  CredentialTypeCsn = 0,
///
  CredentialTypePacs35Bit = 1,
///
  CredentialTypePacs48Bit = 2,
///
  CredentialTypePacs26Bit = 3,
///
  CredentialTypePacsHID37Or40BitOrIClass = 4,
};








/// DeviceInfo used to store found MFi device
SWIFT_CLASS("_TtC3SDM13MfiDeviceInfo")
@interface MfiDeviceInfo : DeviceInfo
@end

@class NDEFRecord;

/// NDEF message contains NDEF records
SWIFT_CLASS("_TtC3SDM11NDEFMessage")
@interface NDEFMessage : NSObject
/// NDEF message records
@property (nonatomic, readonly, copy) NSArray<NDEFRecord *> * _Nonnull records;
/// Creates NDEFMessage with records
/// \param records records to add
///
- (nonnull instancetype)initWithRecords:(NSArray<NDEFRecord *> * _Nonnull)records;
/// Create NDEFMessage with single well-known text record
/// \param text text for single record
///
- (nonnull instancetype)initWithText:(NSString * _Nonnull)text;
/// Create NDEFMessage with single well-known URL record
/// \param url url for single record
///
- (nonnull instancetype)initWithUrl:(NSURL * _Nonnull)url;
/// :nodoc:
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// :nodoc:
@property (nonatomic, readonly, copy) NSString * _Nonnull debugDescription;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

enum TypeNameField : uint8_t;
enum WellKnownType : NSInteger;

/// Record of NDEF message
SWIFT_CLASS("_TtC3SDM10NDEFRecord")
@interface NDEFRecord : NSObject
/// TNF value
@property (nonatomic, readonly) enum TypeNameField tnf;
/// Record Type data
@property (nonatomic, readonly, copy) NSData * _Nonnull type;
/// Record ID data
@property (nonatomic, readonly, copy) NSData * _Nullable recId;
/// Record payload
@property (nonatomic, readonly, copy) NSData * _Nonnull payload;
/// WellKnownType of record
@property (nonatomic, readonly) enum WellKnownType wellKnownType;
/// empty NDEFRecord
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NDEFRecord * _Nonnull empty;)
+ (NDEFRecord * _Nonnull)empty SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Create NDEF record
/// \param tnf TNF
///
/// \param type type data
///
/// \param recId record id data
///
/// \param payload payload data
///
- (nonnull instancetype)initWithTnf:(enum TypeNameField)tnf type:(NSData * _Nonnull)type recId:(NSData * _Nullable)recId payload:(NSData * _Nonnull)payload;
/// :nodoc:
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
@property (nonatomic, readonly) NSUInteger hash;
/// Get URL from record
///
/// returns:
/// URL, if record has well-known uri type, or nil
- (NSURL * _Nullable)urlFromPayload SWIFT_WARN_UNUSED_RESULT;
/// Get text from record
///
/// returns:
/// text (utf8 or utf16 encoding), if record has well-known text type, or nil
- (NSString * _Nullable)textFromPayload SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

/// Possible NDEF records TNF
typedef SWIFT_ENUM(uint8_t, TypeNameField, open) {
///
  TypeNameFieldEmpty = 0,
///
  TypeNameFieldWellKnown = 1,
///
  TypeNameFieldMimeMedia = 2,
///
  TypeNameFieldAbsoluteURI = 3,
///
  TypeNameFieldExternalType = 4,
///
  TypeNameFieldUnknown = 5,
///
  TypeNameFieldUnchanged = 6,
};

/// Possible well-known NDEF record types
typedef SWIFT_ENUM(NSInteger, WellKnownType, open) {
///
  WellKnownTypeUnknown = 0,
///
  WellKnownTypeText = 1,
///
  WellKnownTypeUri = 2,
///
  WellKnownTypeAction = 3,
///
  WellKnownTypeSmartPost = 4,
///
  WellKnownTypeAlternativeCarrier = 5,
///
  WellKnownTypeHandoverCarrier = 6,
///
  WellKnownTypeHandoverRequest = 7,
///
  WellKnownTypeHandoverSelect = 8,
};

/// Types to describe how stores data bytes on tag
typedef SWIFT_ENUM(NSInteger, NFCDataFormat, open) {
///
  NFCDataFormatScanfob = 0,
///
  NFCDataFormatLittleEndian = 1,
};















@interface NSString (SWIFT_EXTENSION(SDM))
/// :nodoc:
- (NSString * _Nonnull)convertedToHexStringFromFormat:(enum ScanDataFormat)format SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (NSString * _Nonnull)convertedHexStringToFormat:(enum ScanDataFormat)format SWIFT_WARN_UNUSED_RESULT;
@end



/// Class to calculate PAC value
SWIFT_CLASS("_TtC3SDM11PacsProfile")
@interface PacsProfile : NSObject
/// Create profile
- (nonnull instancetype)initWithFormat:(NSInteger)format startBit:(NSInteger)startBit length:(NSInteger)length OBJC_DESIGNATED_INITIALIZER;
/// :nodoc:
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// PosiTector 6000 device class, see base <code>Device</code> for all available methods
SWIFT_CLASS("_TtC3SDM20PosiTector6000Device")
@interface PosiTector6000Device : Device
@property (nonatomic, readonly) enum DeviceType deviceType;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull options;
@end

/// error codes used in NSError
typedef SWIFT_ENUM(NSInteger, SDMErrorCode, open) {
///
  SDMErrorCodeBluetoothUnsupported = 1001,
///
  SDMErrorCodeBluetoothUnauthorized = 1002,
///
  SDMErrorCodeBluetoothUnknown = 1003,
///
  SDMErrorCodeBluetoothPoweredOff = 1004,
///
  SDMErrorCodeScanningEndedUnexpectedly = 1005,
///
  SDMErrorCodeOperationTimedOut = 1006,
///
  SDMErrorCodeInvalidPeripheral = 1007,
///
  SDMErrorCodePeripheralFailedToConnectReasonUnknown = 1008,
///
  SDMErrorCodePeripheralServiceNotFound = 1009,
///
  SDMErrorCodePeripheralCharacteristicNotFound = 1010,
///
  SDMErrorCodePeripheralDescriptorsNotFound = 1011,
///
  SDMErrorCodeInvalidDescriptorValue = 1012,
///
  SDMErrorCodeCharacteristicNotInitialized = 1013,
///
  SDMErrorCodeTransportError = 1014,
///
  SDMErrorCodeDeviceNotConnected = 1015,
///
  SDMErrorCodeDeviceNoCurrentTag = 1016,
///
  SDMErrorCodeDeviceInvalidAddressOrLength = 1017,
///
  SDMErrorCodeDeviceLockedAddress = 1018,
///
  SDMErrorCodeDeviceInventoryError = 1019,
///
  SDMErrorCodeDeviceInvalidParameter = 1020,
///
  SDMErrorCodeDeviceOperationTimeout = 1021,
///
  SDMErrorCodeDeviceUnknownCommand = 1022,
///
  SDMErrorCodeDeviceInvalidCommand = 1023,
///
  SDMErrorCodeDeviceIncompleteData = 1024,
///
  SDMErrorCodeDeviceBadResponse = 1025,
///
  SDMErrorCodeDeviceCommandFailed = 1026,
///
  SDMErrorCodeDeviceOptionsFailure = 1027,
///
  SDMErrorCodeDeviceBadCRC = 1028,
///
  SDMErrorCodeDeviceIncompleteFrame = 1029,
///
  SDMErrorCodeDeviceJobFailure = 1030,
///
  SDMErrorCodeNdefParseFailed = 1031,
///
  SDMErrorCodeDeviceWasTurnedOff = 1032,
///
  SDMErrorCodeOther = 1033,
///
  SDMErrorCodeNotSupported = 1034,
///
  SDMErrorCodeNotImplemented = 1035,
};


/// SRS2/XRS2 Stick Reader device class, see base <code>Device</code> for all available methods
SWIFT_CLASS("_TtC3SDM10SRS2Device")
@interface SRS2Device : Device
@property (nonatomic, readonly) enum DeviceType deviceType;
@end


/// Class to keep scan/tag data
SWIFT_CLASS("_TtC3SDM4Scan")
@interface Scan : NSObject <NSCoding>
/// time interval from references date of scan received (Date.timeIntervalSinceReferenceDate)
@property (nonatomic, readonly) NSTimeInterval timestamp;
/// type of tag/barcode scanned
@property (nonatomic, readonly) enum TagType tagType;
/// Barcode/EPC/CSN/PACS tag data
@property (nonatomic, readonly, copy) NSString * _Nullable data;
/// tag data label
@property (nonatomic, readonly) enum ScanDataType dataLabel;
/// tag TID
@property (nonatomic, readonly, copy) NSString * _Nullable tid;
/// tag userdata
@property (nonatomic, readonly, copy) NSString * _Nullable userdata;
/// tag NDEF formatted userdata
@property (nonatomic, readonly, strong) NDEFMessage * _Nullable ndef;
/// Return first non-nil value of data, tid, userdata or ndef
@property (nonatomic, readonly, copy) NSString * _Nonnull getText;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Create scan with NDEF records
/// \param records NDEF records
///
- (nonnull instancetype)initWithRecords:(NSArray<NDEFRecord *> * _Nonnull)records OBJC_DESIGNATED_INITIALIZER;
/// Create scan with barcode value
/// \param barcode barcode value
///
+ (Scan * _Nonnull)scanWithBarcode:(NSString * _Nonnull)barcode SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (void)encodeWithCoder:(NSCoder * _Nonnull)coder;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
/// :nodoc:
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (id _Nullable)objectForKeyedSubscript:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
- (void)setObject:(id _Nullable)newValue forKeyedSubscript:(NSString * _Nonnull)key;
@end

/// Type of tag EPC/CSN, TID and userdata.
typedef SWIFT_ENUM(NSInteger, ScanDataFormat, open) {
/// caused SDM do not read and post corresponding memory
  ScanDataFormatNone = 0,
/// ASCII string
  ScanDataFormatAscii = 1,
/// HEX string
  ScanDataFormatHex = 2,
/// String contained Int number
  ScanDataFormatDecimal = 3,
/// String contrained bytewise decimal numbers: 1023 = 01000203
  ScanDataFormatDecimalBytewise = 4,
///
  ScanDataFormatRfidJournal2013 = 5,
/// NDEF formatted data
  ScanDataFormatNdef = 6,
};

/// Type of scan data
typedef SWIFT_ENUM(NSInteger, ScanDataType, open) {
///
  ScanDataTypeBarcode = 0,
///
  ScanDataTypeEpc = 1,
///
  ScanDataTypeCsn = 2,
///
  ScanDataTypePacs = 3,
};


/// Scanfob® 2006 device class, see base <code>Device</code> for all available methods
SWIFT_CLASS("_TtC3SDM17Scanfob2006Device")
@interface Scanfob2006Device : Device
/// Allows SDM to download all scans after connect
@property (nonatomic) BOOL downloadScansOnConnect;
/// Keep timestamp if batch mode enabled
@property (nonatomic) BOOL keepBatchTimestamp;
/// allows SDM to ask to clean scans after downloading
@property (nonatomic) BOOL askToCleanScansAfterDownloading;
/// Enable batch mode
@property (nonatomic) BOOL batchModeEnabled;
@property (nonatomic, readonly) enum DeviceType deviceType;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull options;
/// :nodoc:
@property (nonatomic, readonly) enum TriggerReadType supportedTriggerRead;
/// :nodoc:
- (void)triggerReadingWithDataType:(enum TriggerReadType)dataType;
@end


/// Scanfob® 3002 device class, see base <code>Device</code> for all available methods
SWIFT_CLASS("_TtC3SDM17Scanfob3002Device")
@interface Scanfob3002Device : Device
/// enable or disable constant read mode
@property (nonatomic) BOOL constantReadMode;
/// Return <code>DeviceType.scanfob3002</code>
@property (nonatomic, readonly) enum DeviceType deviceType;
@property (nonatomic, readonly) BOOL madeBySerialIO;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull options;
@property (nonatomic, readonly) BOOL supportsConstantReadMode;
@property (nonatomic, readonly) enum TriggerReadType supportedTriggerRead;
- (void)triggerReadingWithDataType:(enum TriggerReadType)dataType;
@end


/// Scanfob® BB2 NFC device class, see base <code>Device</code> for all available methods
SWIFT_CLASS("_TtC3SDM19ScanfobNfcBB2Device")
@interface ScanfobNfcBB2Device : Device
/// enable reader sound signal on scanning tag, default value is true
@property (nonatomic) BOOL beepOnScan;
/// set auto off timer on reader in seconds (1s … 18h), default value is 8 mins
@property (nonatomic) NSInteger autoOff;
/// device antenna power output, 0…19 dBm, default value is 10
@property (nonatomic) NSInteger outputPower;
/// enable or disable constant read mode
@property (nonatomic) BOOL constantReadMode;
/// format to read tag EPC, if it doesn’t equals <code>.none</code> Scan <code>data</code> will be set
@property (nonatomic) enum ScanDataFormat epcOutputFormat;
/// format to read tag userdata, if it doesn’t equals <code>.none</code> Scan <code>userdata</code> or <code>ndef</code> will be set
@property (nonatomic) enum ScanDataFormat userdataOutputFormat;
/// number of hex digits in userdata to read and write operations.
@property (nonatomic) NSInteger userdataLength;
/// Scanning command timeout. Default value is 0.6 sec
@property (nonatomic) NSTimeInterval scanningTime;
/// Command scanning enter interval. Default value is 0.6 sec. At the end of a scanning the device awaits a time equal to a Tinterval before starting the following scanning
@property (nonatomic) NSTimeInterval intervalTime;
/// only iso15693 or iso14444a
@property (nonatomic) enum TagType isoStandard;
@property (nonatomic, readonly) enum DeviceType deviceType;
@property (nonatomic, readonly) BOOL madeBySerialIO;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull options;
@property (nonatomic, readonly) BOOL supportsConstantReadMode;
@property (nonatomic, readonly) enum TriggerReadType supportedTriggerRead;
- (void)triggerReadingWithDataType:(enum TriggerReadType)dataType;
@end


/// Scanfob® BB2 Ultra device class, see base <code>Device</code> for all available methods
SWIFT_CLASS("_TtC3SDM21ScanfobUltraBB2Device")
@interface ScanfobUltraBB2Device : Device
/// enable reader sound signal on scanning tag, default value is true
@property (nonatomic) BOOL beepOnScan;
/// set auto off timer on reader in seconds (1s … 18h), default value is 8 mins
@property (nonatomic) NSInteger autoOff;
/// device antenna power output, 0…19 dBm, default value is 10
@property (nonatomic) NSInteger outputPower;
/// enable or disable constant read mode
@property (nonatomic) BOOL constantReadMode;
/// format to read tag EPC, if it doesn’t equals <code>.none</code> Scan <code>data</code> will be set
@property (nonatomic) enum ScanDataFormat epcOutputFormat;
/// format to read tag TID, if it doesn’t equals <code>.none</code> Scan <code>tid</code> will be set
@property (nonatomic) enum ScanDataFormat tidOutputFormat;
/// length of TID to read
@property (nonatomic) NSInteger tidLength;
/// format to read tag userdata, if it doesn’t equals <code>.none</code> Scan <code>userdata</code> or <code>ndef</code> will be set
@property (nonatomic) enum ScanDataFormat userdataOutputFormat;
/// userdata length to read and write operations.
@property (nonatomic) NSInteger userdataLength;
/// Scanning command timeout. Default value is 0.6 sec
@property (nonatomic) NSTimeInterval scanningTime;
/// Command scanning enter interval. Default value is 0.6 sec. At the end of a scanning the device awaits a time equal to a Tinterval before starting the following scanning
@property (nonatomic) NSTimeInterval intervalTime;
@property (nonatomic, readonly) enum DeviceType deviceType;
@property (nonatomic, readonly) BOOL madeBySerialIO;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull options;
@property (nonatomic, readonly) BOOL supportsConstantReadMode;
@property (nonatomic, readonly) enum TriggerReadType supportedTriggerRead;
- (void)triggerReadingWithDataType:(enum TriggerReadType)dataType;
@end

@class SimpleLogger;
@class NSUserDefaults;
@class UIImage;
@class UIViewController;

/// Main SDM class, singleton.
SWIFT_CLASS("_TtC3SDM21SerialioDeviceManager")
@interface SerialioDeviceManager : NSObject
/// :nodoc:
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// :nodoc:
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// The shared Singleton
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) SerialioDeviceManager * _Nonnull shared;)
+ (SerialioDeviceManager * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// current framework version
@property (nonatomic, readonly, copy) NSString * _Nonnull version;
/// Logger for SDM, Create instance of <code>SimpleLogger</code> and set this property to get text logs in “\Library\Logs” folder
@property (nonatomic, strong) SimpleLogger * _Nullable logger;
/// UserDefalts used for storing SerialioDeviceManager recent devices and settings.
@property (nonatomic, strong) NSUserDefaults * _Nonnull userDefaults;
/// If set storeOnlyRecentDevices = true, SDM will saves to UserDefaults only recent devices, application can set options by self before call start()
@property (nonatomic) BOOL storeOnlyRecentDevices;
/// Current CoreBluetooth state. See <code>CBManagerState</code> for values
@property (nonatomic, readonly) CBManagerState currentBluetoothState;
/// By default SDM scanning for Bluetooth® LE devices, only if there is not found recent devices or
/// if SDM viewController is visible,
/// set <code>forceBleDeviceScanning</code> to true, to scanning for devices always
@property (nonatomic) BOOL forceBleDeviceScanning;
/// Start SDM. Set required options, then call this method.
- (void)start;
/// Enable battery power polling for all BLE devices, having Battery service, default is false
@property (nonatomic) BOOL batteryServiceEnabled;
/// Battery power polling timeout, default value is 1 minute
@property (nonatomic) NSTimeInterval batteryPollTimeout;
/// 5 images of battery: empty, 25%, 50%, 75%, 100%
@property (nonatomic, copy) NSArray<UIImage *> * _Nonnull batteryImages;
/// Main view controller, allows to set SDM options and configures devices. Required application to have embedded Eureka.framework.
/// It doesn’t have public <code>init()</code>, use <code>SerialioDeviceManager.viewController</code> to get it and present in UINavigationController or
/// just use UIViewController.presentSerialioDeviceManager()
@property (nonatomic, strong) UIViewController * _Nonnull viewController;
/// Show if SDM dialog is visible
@property (nonatomic, readonly) BOOL isViewControllerVisible;
/// number of seconds after user taps and connects any device to close view controller automaticaly. Default value is 2. Set it to 0 to disable autoclose
@property (nonatomic) NSTimeInterval autoCloseTimeout;
/// Show/hide SDM options in <code>viewController</code>
@property (nonatomic) BOOL isOptionsVisible;
/// Enables SerialioDeviceManager to send notification
@property (nonatomic) BOOL useNotifications;
/// Array of discovered <code>DeviceInfo</code>s
@property (nonatomic, readonly, copy) NSArray<DeviceInfo *> * _Nonnull foundDevices;
/// Array of connected <code>Device</code>s
@property (nonatomic, readonly, copy) NSArray<Device *> * _Nonnull connectedDevices;
/// Find connected device with <code>options</code>
/// \param options dictionary returned <code>recentDevices</code>
///
- (Device * _Nullable)connectedDeviceWithOptions:(NSDictionary<NSString *, id> * _Nonnull)options SWIFT_WARN_UNUSED_RESULT;
/// Find connected device by name
/// \param byName Name of device
///
- (Device * _Nullable)connectedDeviceByName:(NSString * _Nonnull)byName SWIFT_WARN_UNUSED_RESULT;
/// Find found device by name
/// \param byName Name of device
///
- (DeviceInfo * _Nullable)foundDeviceByName:(NSString * _Nonnull)byName SWIFT_WARN_UNUSED_RESULT;
/// Connects to found device
/// \param deviceInfo DeviceInfo received from foundDevices array or received in <code>Event.foundDevice</code>
///
- (void)connectWithDeviceInfo:(DeviceInfo * _Nonnull)deviceInfo;
/// Disconnects device
/// \param device Device to disconnect
///
- (void)disconnectWithDevice:(Device * _Nonnull)device;
/// Disconnect all connected device of transport type
- (void)disconnectAllWithMfi:(BOOL)mfi ble:(BOOL)ble wisnap:(BOOL)wisnap;
/// Disconnect all connected device
- (void)disconnectAll;
/// Enables to connect to last recent devices
@property (nonatomic) BOOL connectToLastRecentDevicesEnabled;
/// Debug only option to disbale saving device options
@property (nonatomic) BOOL enableSavingDeviceOptions;
/// Max number of recent devices, new connected device will remove oldest device from recent
@property (nonatomic) NSInteger maxRecentDevices;
/// Array of recent devices unique name
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull recentDeviceUniqueNames;
/// Array of recent devices name
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull recentDeviceNames;
///
- (NSString * _Nullable)recentDeviceName:(NSString * _Nonnull)uniqueName SWIFT_WARN_UNUSED_RESULT;
/// Remove device from recent and its settings
- (void)removeDeviceOptionsWithDevice:(Device * _Nullable)device;
/// Allows to show all nearby devices including unsupported
@property (nonatomic) BOOL showUnknownDevices;
/// Enable device type filter. If it’s enabled, SDM ignores devices which type doesn’t contain in <code>deviceTypeFilter</code>
@property (nonatomic) BOOL deviceTypeFilterEnabled;
@end


@interface SerialioDeviceManager (SWIFT_EXTENSION(SDM))
/// Returns UIViewCOntroller to write NDEF records to tags. This view controllers is opened from SDM -> Device -> “Write tag” option,
/// if device supports writting
/// So usually it’s not required to create and show it in code.
/// But if you don’t use <code>SerialioDeviceManager.viewController</code>, this can be created and presented to allow user to write tag
+ (UIViewController * _Nonnull)createWriteNDEFViewControllerWithDevice:(Device * _Nonnull)device SWIFT_WARN_UNUSED_RESULT;
@end


@interface SerialioDeviceManager (SWIFT_EXTENSION(SDM))
/// Debug method to create fake device
/// Do not use in real projects. It does nothing
- (Device * _Nonnull)createDeviceWithName:(NSString * _Nonnull)name SWIFT_WARN_UNUSED_RESULT;
@end


@interface SerialioDeviceManager (SWIFT_EXTENSION(SDM))
/// Returns UIViewCOntroller to write data to tags. This view controllers is opened from SDM -> Device -> “Write tag” option,
/// if device supports writting
/// So usually it’s not required to create and show it in code.
/// But if you don’t use <code>SerialioDeviceManager.viewController</code>, this can be created and presented to allow user to write tag
+ (UIViewController * _Nonnull)createWriteUserdataViewControllerWithDevice:(Device * _Nonnull)device SWIFT_WARN_UNUSED_RESULT;
@end



@interface SerialioDeviceManager (SWIFT_EXTENSION(SDM))
/// Allows to keep iOS device awake from last SDM activity
@property (nonatomic) NSTimeInterval keepAwakeTimeInterval;
/// Keep enable only ONE <code>DeviceType</code>
@property (nonatomic) enum DeviceType allowedDeviceType;
@end

@class NSError;

@interface SerialioDeviceManager (SWIFT_EXTENSION(SDM))
/// Reads EPC/CSN of current tag. For using in Obj-C code. Use <code>Device.readEPC(outputFormat:complete:)</code> in Swift
/// \param device device to read
///
/// \param outputFormat data format to convert
///
/// \param complete complete handler, on success completion handler calls with <code>Scan.data</code> and <code>Scan.dataLabel</code> filled. Otherwise 1st parameter is nil
///
- (void)readEPC:(Device * _Nonnull)device outputFormat:(enum ScanDataFormat)outputFormat complete:(void (^ _Nonnull)(Scan * _Nullable, NSError * _Nullable))complete;
/// Reads tag id (TID) of current tag. For using in Obj-C code. Use <code>Device.readTagID(outputFormat:complete:)</code> in Swift
/// \param device device to read
///
/// \param outputFormat data format to convert
///
/// \param complete complete handler, on success completion handler calls with <code>Scan.tid</code> filled. Otherwise 1st parameter is nil
///
- (void)readTagID:(Device * _Nonnull)device outputFormat:(enum ScanDataFormat)outputFormat complete:(void (^ _Nonnull)(Scan * _Nullable, NSError * _Nullable))complete;
/// Reads userdata memory of current tag.  For using in Obj-C code. Use <code>Device.readUserdata(outputFormat:offset:length:complete:)</code> in Swift
/// \param device device to read
///
/// \param outputFormat data format to convert
///
/// \param offset userdata memory offset to reading, not applicable for NDEF formatted data
///
/// \param length userdata memory length to reading, not applicable for NDEF formatted data, set to 0 to use current value of <code>Device.userdataLength</code>
///
/// \param complete , on success completion handler calls with <code>Scan.userdata</code> or <code>Scan.ndef</code> filled. Otherwise 1st parameter is nil
///
- (void)readUserdata:(Device * _Nonnull)device outputFormat:(enum ScanDataFormat)outputFormat offset:(NSInteger)offset length:(NSInteger)length complete:(void (^ _Nonnull)(Scan * _Nullable, NSError * _Nullable))complete;
/// Write EPC/CSN to current tag.  For using in Obj-C code. Use <code>Device.write(epc:complete:)</code> in Swift
/// \param device device to write
///
/// \param epc new EPC/CSN to write
///
/// \param complete complete handler, parameter is nil if written successfully
///
- (void)write:(Device * _Nonnull)device epc:(NSString * _Nonnull)epc complete:(void (^ _Nonnull)(NSError * _Nullable))complete;
/// Write userdata memory of current tag. For using in Obj-C code. Use <code>Device.write(userdata:format:offset:complete:)</code> in Swift
/// \param device device to write
///
/// \param userdata userdata to write
///
/// \param format format of userdata
///
/// \param offset userdata memory offset to writing
///
/// \param complete complete handler, parameter is nil if written successfully
///
- (void)write:(Device * _Nonnull)device userdata:(NSString * _Nonnull)userdata format:(enum ScanDataFormat)format offset:(NSInteger)offset complete:(void (^ _Nonnull)(NSError * _Nullable))complete;
/// Writes NDEFMessage to userdata memory of current tag. For using in Obj-C code. Use <code>Device.write(ndef:complete:)</code> in Swift
/// \param device device to write
///
/// \param ndef NDEF message to write
///
/// \param complete complete handler, parameter is nil if written successfully
///
- (void)write:(Device * _Nonnull)device ndef:(NDEFMessage * _Nonnull)ndef complete:(void (^ _Nonnull)(NSError * _Nullable))complete;
/// Changes constant mode for device. For using in Obj-C code. Use <code>Device.enableConstantMode(_:complete:)</code> in Swift
/// \param device device to change constant mode
///
/// \param enable new value
///
/// \param complete complete handler, parameter is nil if changed successfully
///
- (void)enableConstantMode:(Device * _Nonnull)device enable:(BOOL)enable complete:(void (^ _Nonnull)(NSError * _Nullable))complete;
/// Allows to send data directly to device
/// \param data data to send
///
/// \param device target Device
///
- (void)sendWithData:(NSData * _Nonnull)data device:(Device * _Nonnull)device;
/// Allows to send data directly to device, if device responds with some data,
/// it will be received as Event.recieved(scan:device:) and SDM notification
/// \param data data to send
///
/// \param device target Device
///
/// \param complete completation handler called when data is sent to devcie
///
- (void)sendWithData:(NSData * _Nonnull)data device:(Device * _Nonnull)device complete:(void (^ _Nonnull)(NSError * _Nullable))complete;
/// Allows to send data directly to device, and get the response
/// \param data data to send
///
/// \param device target Device
///
/// \param checkResponse handler to check response is completed, parameter is received data buffer, it must return true if response is complete
///
/// \param complete completation handler called when data is sent to devcie and checkResponse return true, parameter is received data and error, the each can be nil
///
- (void)sendWithData:(NSData * _Nonnull)data device:(Device * _Nonnull)device checkResponse:(BOOL (^ _Nonnull)(NSData * _Nonnull))checkResponse complete:(void (^ _Nonnull)(NSData * _Nullable, NSError * _Nullable))complete;
/// Saves device options. if device is connected, set up device. Otherwise device will be set up on connect. For using in Obj-C code. Use <code>Device.applyUserOptions(complete:)</code> in Swift
/// \param device device to save option
///
/// \param complete complete handler, parameter is nil if saved and set up device successfully
///
- (void)applyUserOptions:(Device * _Nonnull)device complete:(void (^ _Nonnull)(NSError * _Nullable))complete;
@end




@interface SerialioDeviceManager (SWIFT_EXTENSION(SDM))
/// Key for new <code>CBManagerState</code> as NSNumber(value: Int(state)). To get value use <code>CBManagerState state = (CBManagerState)[userinfo[UserInfoStateKey] integerValue]</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull UserInfoStateKey;)
+ (NSString * _Nonnull)UserInfoStateKey SWIFT_WARN_UNUSED_RESULT;
/// Key for <code>Device</code> object, can be nil for some notifications
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull UserInfoDeviceKey;)
+ (NSString * _Nonnull)UserInfoDeviceKey SWIFT_WARN_UNUSED_RESULT;
/// Key for <code>NSArray</code> of <code>Device</code> objects, can be empty
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull UserInfoDevicesKey;)
+ (NSString * _Nonnull)UserInfoDevicesKey SWIFT_WARN_UNUSED_RESULT;
/// Key for NSError object
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull UserInfoErrorKey;)
+ (NSString * _Nonnull)UserInfoErrorKey SWIFT_WARN_UNUSED_RESULT;
/// Key for <code>Scan</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull UserInfoScanKey;)
+ (NSString * _Nonnull)UserInfoScanKey SWIFT_WARN_UNUSED_RESULT;
/// Key for <code>TagType</code> value as NSNumber(value: Int(tagType)). To get value use <code>TagType tagType = (TagType)[userinfo[UserInfoTagTypeKey] integerValue]</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull UserInfoTagTypeKey;)
+ (NSString * _Nonnull)UserInfoTagTypeKey SWIFT_WARN_UNUSED_RESULT;
/// Key for <code>NSString</code>, can be <code>nil</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull UserInfoTextKey;)
+ (NSString * _Nonnull)UserInfoTextKey SWIFT_WARN_UNUSED_RESULT;
/// Key for <code>NSString</code>, can be <code>nil</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull UserInfoDetailsKey;)
+ (NSString * _Nonnull)UserInfoDetailsKey SWIFT_WARN_UNUSED_RESULT;
/// Key for <code>Float</code> value as NSNumber(value: Float(progress)). To get value use <code>float progress = [userinfo[UserInfoProgressKey] floatValue]</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull UserInfoProgressKey;)
+ (NSString * _Nonnull)UserInfoProgressKey SWIFT_WARN_UNUSED_RESULT;
/// posted on underlying CBCentralManager state changes. Take note that if the <code>CBCentralManager</code> state
/// goes from poweredOn to something lower, all your peripherals will be invalidated and need to be discovered again.
/// The new <code>CBManagerState</code> can be found in the notification’s userInfo with <code>SerialioDeviceManager.UserInfoStateKey</code> key
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull BLEStateChanged;)
+ (NSNotificationName _Nonnull)BLEStateChanged SWIFT_WARN_UNUSED_RESULT;
/// posted on SDM add new device to found device list. Use <code>SerialioDeviceManager.UserInfoDeviceKey</code> to get <code>DeviceInfo</code> from notification userInfo
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull FoundDevice;)
+ (NSNotificationName _Nonnull)FoundDevice SWIFT_WARN_UNUSED_RESULT;
/// posted on SDM when device is disappeared from found device list. Use <code>SerialioDeviceManager.UserInfoDevicesKey</code> to get array of <code>DeviceInfo</code> from notification userInfo
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull LostDevice;)
+ (NSNotificationName _Nonnull)LostDevice SWIFT_WARN_UNUSED_RESULT;
/// posted on SDM when deviceInfo is updated, with name, RSSI, etc. Use <code>SerialioDeviceManager.UserInfoDeviceKey</code> to get <code>DeviceInfo</code> from notification userInfo
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull UpdateDeviceInfo;)
+ (NSNotificationName _Nonnull)UpdateDeviceInfo SWIFT_WARN_UNUSED_RESULT;
/// posted on SDM start connecting to device. Use <code>SerialioDeviceManager.UserInfoDeviceKey</code> to get <code>Device</code> from notification userInfo
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull ConnectingToDevice;)
+ (NSNotificationName _Nonnull)ConnectingToDevice SWIFT_WARN_UNUSED_RESULT;
/// posted on SDM did connect to device. Use <code>SerialioDeviceManager.UserInfoDeviceKey</code> to get <code>Device</code> from notification userInfo
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull ConnectedToDevice;)
+ (NSNotificationName _Nonnull)ConnectedToDevice SWIFT_WARN_UNUSED_RESULT;
/// posted on SDM disconnected device. Use <code>SerialioDeviceManager.UserInfoDeviceKey</code> to get <code>Device</code> and <code>SerialioDeviceManager.UserInfoErrorKey</code> to get NSError from notification userInfo (error can be nil)
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull DisconnectedDevice;)
+ (NSNotificationName _Nonnull)DisconnectedDevice SWIFT_WARN_UNUSED_RESULT;
/// posted on SDM did receive “tag detected” from some readers (ex idChamp® RS4). Use <code>SerialioDeviceManager.UserInfoDeviceKey</code>, <code>SerialioDeviceManager.UserInfoTagTypeKey</code> to get more info
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull DetectedTag;)
+ (NSNotificationName _Nonnull)DetectedTag SWIFT_WARN_UNUSED_RESULT;
/// posted on SDM did receive “tag lost” from some readers (ex idChamp® RS4). Use <code>SerialioDeviceManager.UserInfoDeviceKey</code>, <code>SerialioDeviceManager.UserInfoTagTypeKey</code> to get more info
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull LostTag;)
+ (NSNotificationName _Nonnull)LostTag SWIFT_WARN_UNUSED_RESULT;
/// posted on SDM did receive barcode/tag data from reader. Use <code>SerialioDeviceManager.UserInfoDeviceKey</code>, <code>SerialioDeviceManager.UserInfoScanKey</code> for notification userInfo
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull ReceivedScan;)
+ (NSNotificationName _Nonnull)ReceivedScan SWIFT_WARN_UNUSED_RESULT;
/// posted on SDM got updated device battery info. Use <code>SerialioDeviceManager.UserInfoDeviceKey</code> key to get device. And check <code>Device.batteryPercentage</code> and <code>Device.batteryPowerState</code> for values
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull UpdatedBatteryInfo;)
+ (NSNotificationName _Nonnull)UpdatedBatteryInfo SWIFT_WARN_UNUSED_RESULT;
/// posted when SDM performs indeterminate operation to notify user to wait. Notification userinfo values for <code>SerialioDeviceManager.UserInfoTextKey</code> and <code>SerialioDeviceManager.UserInfoDetailsKey</code> can have some additional info.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull NotifyIndeterminate;)
+ (NSNotificationName _Nonnull)NotifyIndeterminate SWIFT_WARN_UNUSED_RESULT;
/// posted when SDM performs determinate operation to notify user to wait. Notification userinfo values for <code>SerialioDeviceManager.UserInfoProgressKey</code>, <code>SerialioDeviceManager.UserInfoTextKey</code> and <code>SerialioDeviceManager.UserInfoDetailsKey</code> can have some additional info.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull NotifyDeterminate;)
+ (NSNotificationName _Nonnull)NotifyDeterminate SWIFT_WARN_UNUSED_RESULT;
/// posted when SDM finished operation for <code>NotifyIndeterminate</code> and <code>NotifyDeterminate</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull NotifyHide;)
+ (NSNotificationName _Nonnull)NotifyHide SWIFT_WARN_UNUSED_RESULT;
/// posted when SDM notifies user with some info. Notification userinfo values for <code>SerialioDeviceManager.UserInfoTextKey</code> and <code>SerialioDeviceManager.UserInfoDetailsKey</code> can have some additional info
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull NotifyText;)
+ (NSNotificationName _Nonnull)NotifyText SWIFT_WARN_UNUSED_RESULT;
/// posted on SDM errors. Use notification userinfo values for <code>SerialioDeviceManager.UserInfoErrorKey</code> and <code>SerialioDeviceManager.UserInfoDeviceKey</code> to get error and device (optional)
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull ErrorNotification;)
+ (NSNotificationName _Nonnull)ErrorNotification SWIFT_WARN_UNUSED_RESULT;
/// posted on SDM view controller closed.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull SDMViewControllerDismissed;)
+ (NSNotificationName _Nonnull)SDMViewControllerDismissed SWIFT_WARN_UNUSED_RESULT;
/// posted on device options are updated for connected device. Use notification userinfo value for <code>SerialioDeviceManager.UserInfoDeviceKey</code> to get device
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull DeviceOptionsUpdated;)
+ (NSNotificationName _Nonnull)DeviceOptionsUpdated SWIFT_WARN_UNUSED_RESULT;
@end

@protocol SimpleLoggerDataSource;
@class NSProgress;

SWIFT_CLASS("_TtC3SDM12SimpleLogger")
@interface SimpleLogger : NSObject
/// Days to keep log files, mimimum allowed value is 3 days, default is 15 days
@property (nonatomic) NSInteger daysToKeepLogFiles;
@property (nonatomic, readonly, copy) NSURL * _Nonnull folderURL;
@property (nonatomic, copy) NSString * _Nullable filenameSuffix;
/// Create logger instance. log files folder is “/Library/Logs”
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Create logger instance
/// \param folder log files folder
///
- (nonnull instancetype)initWithFolder:(NSURL * _Nonnull)folder OBJC_DESIGNATED_INITIALIZER;
- (void)addDataSource:(id <SimpleLoggerDataSource> _Nonnull)dataSource;
- (void)removeDataSource:(id <SimpleLoggerDataSource> _Nonnull)dataSource;
- (void)flushCurrentFile;
- (NSData * _Nullable)makeZippedDataWithProgress:(NSProgress * _Nullable)parentProgress SWIFT_WARN_UNUSED_RESULT;
- (void)log:(NSString * _Nonnull)text file:(NSString * _Nonnull)file function:(NSString * _Nonnull)function line:(NSUInteger)line;
- (void)cleanLogFolder;
@end


SWIFT_PROTOCOL("_TtP3SDM22SimpleLoggerDataSource_")
@protocol SimpleLoggerDataSource
@property (nonatomic, readonly, copy) NSArray<NSData *> * _Nonnull simpleLoggerZipData;
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull simpleLoggerZipName;
- (void)simpleLoggerClean;
@end


/// idChamp® Smart 3101 device class, see base <code>Device</code> for all available methods
SWIFT_CLASS("_TtC3SDM15Smart3101Device")
@interface Smart3101Device : Device
/// enable or disable constant read mode
@property (nonatomic) BOOL constantReadMode;
@property (nonatomic, readonly) enum DeviceType deviceType;
@property (nonatomic, readonly) BOOL madeBySerialIO;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull options;
@property (nonatomic, readonly) BOOL supportsConstantReadMode;
@end

/// String separator
typedef SWIFT_ENUM(NSInteger, StringSeparator, open) {
///
  StringSeparatorNothing = 0,
///
  StringSeparatorComma = 1,
///
  StringSeparatorCommaAndSpace = 2,
///
  StringSeparatorSpace = 3,
///
  StringSeparatorCarriageReturn = 4,
///
  StringSeparatorLinefeed = 5,
///
  StringSeparatorCrlf = 6,
///
  StringSeparatorTab = 7,
};


/// TSL 1128 device class, see base <code>Device</code> for all available methods
SWIFT_CLASS("_TtC3SDM13TSL1128Device")
@interface TSL1128Device : Device
/// device antenna power output, 10…29 dBm
@property (nonatomic) NSInteger outputPower;
/// enable or disable constant read mode
@property (nonatomic) BOOL constantReadMode;
/// format to read tag EPC, if it doesn’t equals <code>.none</code> Scan <code>data</code> will be set
@property (nonatomic) enum ScanDataFormat epcOutputFormat;
/// format to read tag TID, if it doesn’t equals <code>.none</code> Scan <code>tid</code> will be set
@property (nonatomic) enum ScanDataFormat tidOutputFormat;
/// length of TID to read, allowed values are 16 or 24
@property (nonatomic) NSInteger tidLength;
/// format to read tag userdata, if it doesn’t equals <code>.none</code> Scan <code>userdata</code> or <code>ndef</code> will be set
@property (nonatomic) enum ScanDataFormat userdataOutputFormat;
/// max length of userdata to read
@property (nonatomic) NSInteger userdataLength;
/// merge tags data into one Scan, when reading several tags simultanously
@property (nonatomic) BOOL shouldMergeTagsData;
/// separator for merged tags data into one Scan, when reading several tags simultanously. Defailt value <code>StringSeparator.commaAndSpace</code>
@property (nonatomic) enum StringSeparator mergeTagsSeparator;
@property (nonatomic, readonly) enum DeviceType deviceType;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull options;
@property (nonatomic, readonly) enum TriggerReadType supportedTriggerRead;
- (void)triggerReadingWithDataType:(enum TriggerReadType)dataType;
@property (nonatomic, readonly) BOOL supportsConstantReadMode;
@end


///
typedef SWIFT_ENUM(NSInteger, TagType, open) {
///
  TagTypeUnknown = 0,
///
  TagTypeBarcode = 1,
///
  TagTypeMagStripe = 2,
/// EPC Gen II tags and cards
  TagTypeEpcGenII = 3,
/// ISO 14443a
  TagTypeIso14443a = 4,
/// ISO 14443b
  TagTypeIso14443b = 5,
/// ISO 14444a
  TagTypeIso14444a = 6,
/// ISO 15693
  TagTypeIso15693 = 7,
/// MIFARE® Classic 1k
  TagTypeMifareClassic1K = 8,
/// MIFARE® Classic 4k
  TagTypeMifareClassic4K = 9,
/// MIFARE® Ultralight
  TagTypeMifareUltrlight = 10,
/// MIFARE® Ultralight C
  TagTypeMifareUltrlightC = 11,
/// MIFARE® Plus S 2k
  TagTypeMifare2kS = 12,
/// HID iClass H10301
  TagTypeIClassH10301 = 13,
/// Mifare® Desfire®
  TagTypeNxpDesfire = 14,
/// NTAG216
  TagTypeNtag216 = 15,
/// iClass Seos
  TagTypeSeos = 16,
/// LEGIC
  TagTypeLegic = 17,
/// FeliCa
  TagTypeFelica = 18,
/// SRX
  TagTypeSrx = 19,
/// NFC Peer-to-Peer
  TagTypeNfcp2p = 20,
/// Bluetooth Low Energy
  TagTypeBle = 21,
/// Topaz
  TagTypeTopaz = 22,
/// CTS256 / CTS512
  TagTypeCts = 23,
/// HID Prox
  TagTypeHidProx = 24,
/// EM4x02/CASI-RUSCO
  TagTypeEm4102 = 25,
/// HITAG 1/HITAG S
  TagTypeHitag1S = 26,
/// HITAG 2
  TagTypeHitag2 = 27,
/// EM4x50
  TagTypeEm4150 = 28,
/// T55x7
  TagTypeAt5555 = 29,
/// ISO FDX-B
  TagTypeIsoFdx = 30,
/// EM4026
  TagTypeEm4026 = 31,
/// HITAG U
  TagTypeHitagU = 32,
/// EM4305
  TagTypeEm4305 = 33,
/// ISO HDX/TIRIS
  TagTypeTiris = 34,
/// Cotag
  TagTypeCotag = 35,
/// ioProx
  TagTypeIoProx = 36,
/// Indala
  TagTypeIndiTag = 37,
/// NexWatch
  TagTypeHoneyTag = 38,
/// AWID
  TagTypeAwid = 39,
/// G-Prox
  TagTypeGProx = 40,
/// Pyramid
  TagTypePyramid = 41,
/// Keri
  TagTypeKeri = 42,
/// Deister
  TagTypeDeister = 43,
/// Cardax
  TagTypeCardax = 44,
/// Nedap
  TagTypeNedap = 45,
/// PAC
  TagTypePac = 46,
/// IDTECK
  TagTypeIdteck = 47,
/// UltraProx
  TagTypeUltraProx = 48,
/// ICT
  TagTypeIct = 49,
/// Isonas
  TagTypeIsonas = 50,
};

























@interface UINavigationController (SWIFT_EXTENSION(SDM))
/// :nodoc:
@property (nonatomic, readonly) UIStatusBarStyle preferredStatusBarStyle;
@end





















@interface UIViewController (SWIFT_EXTENSION(SDM))
/// Presents SDM view controller in UINavigationController as formSheet. useful to use as selector in UIBarButtonItem cnstructor
- (void)presentSerialioDeviceManager;
@end








/// WiSnap-connected device class, see base <code>Device</code> for all available methods
SWIFT_CLASS("_TtC3SDM12WiSnapDevice")
@interface WiSnapDevice : Device
@property (nonatomic, readonly) enum DeviceType deviceType;
@property (nonatomic, readonly) BOOL madeBySerialIO;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull options;
/// :nodoc:
- (void)readECRType6WeightWithComplete:(void (^ _Nonnull)(void))complete;
@end


/// DeviceInfo used to store found WiSnap device
SWIFT_CLASS("_TtC3SDM16WiSnapDeviceInfo")
@interface WiSnapDeviceInfo : DeviceInfo
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif
